<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>操作系统复习整理 | Wawa</title><noscript>开启JavaScript才能访问本站哦~</noscript><link rel="icon" href="/img/pwa/sheep.png"><!-- index.css--><link rel="stylesheet" href="/css/index.css?v=2.1.15"><!-- inject head--><link rel="canonical" href="https://wawaoo0210.github.io/2025/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><!-- aplayer--><!-- swiper--><!-- fancybox ui--><!-- katex--><!-- Open Graph--><meta name="description" content="操作系统复习整理操作系统的结构操作系统接口 命令行界面(Command-Line Interface, CLI) 图形用户界面(Graphic-User Interface, GUI) 系统调用内核提供一系列具备预定功能的多内核函数，通过一组称为系统调用(System call)的接口呈现给用户。"><!-- pwa--><meta name="apple-mobile-web-app-capable" content="Wawa"><meta name="theme-color" content="var(--efu-main)"><meta name="apple-mobile-web-app-status-bar-style" content="var(--efu-main)"><link rel="bookmark" href="/img/pwa/sheep.png"><link rel="apple-touch-icon" href="/img/pwa/sheep.png" sizes="180x180"><script>console.log(' %c Solitude %c ' + '2.1.15' + ' %c https://github.com/everfu/hexo-theme-solitude',
    'background:#35495e ; padding: 1px; border-radius: 3px 0 0 3px;  color: #fff',
    'background:#ff9a9a ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff',
    'background:unset ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff')
</script><script>(()=>{
        const saveToLocal = {
            set: function setWithExpiry(key, value, ttl) {
                if (ttl === 0)
                    return
                const now = new Date()
                const expiryDay = ttl * 86400000
                const item = {
                    value: value,
                    expiry: now.getTime() + expiryDay
                }
                localStorage.setItem(key, JSON.stringify(item))
            },
            get: function getWithExpiry(key) {
                const itemStr = localStorage.getItem(key)

                if (!itemStr) {
                    return undefined
                }
                const item = JSON.parse(itemStr)
                const now = new Date()

                if (now.getTime() > item.expiry) {
                    localStorage.removeItem(key)
                    return undefined
                }
                return item.value
            }
        };
        window.utils = {
            saveToLocal: saveToLocal,
            getCSS: (url, id = false) => new Promise((resolve, reject) => {
              const link = document.createElement('link')
              link.rel = 'stylesheet'
              link.href = url
              if (id) link.id = id
              link.onerror = reject
              link.onload = link.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                link.onload = link.onreadystatechange = null
                resolve()
              }
              document.head.appendChild(link)
            }),
            getScript: (url, attr = {}) => new Promise((resolve, reject) => {
              const script = document.createElement('script')
              script.src = url
              script.async = true
              script.onerror = reject
              script.onload = script.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                script.onload = script.onreadystatechange = null
                resolve()
              }

              Object.keys(attr).forEach(key => {
                script.setAttribute(key, attr[key])
              })

              document.head.appendChild(script)
            }),
            addGlobalFn: (key, fn, name = false, parent = window) => {
                const globalFn = parent.globalFn || {}
                const keyObj = globalFn[key] || {}

                if (name && keyObj[name]) return

                name = name || Object.keys(keyObj).length
                keyObj[name] = fn
                globalFn[key] = keyObj
                parent.globalFn = globalFn
            },
            addEventListenerPjax: (ele, event, fn, option = false) => {
              ele.addEventListener(event, fn, option)
              utils.addGlobalFn('pjax', () => {
                  ele.removeEventListener(event, fn, option)
              })
          },
        }
    })()</script><!-- theme--><script>initTheme = () => {
    let isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const cachedMode = utils.saveToLocal.get('theme');
    if (cachedMode === undefined) {
        const nowMode =
            isDarkMode ? 'dark' : 'light'
        document.documentElement.setAttribute('data-theme', nowMode);
    } else {
        document.documentElement.setAttribute('data-theme', cachedMode);
    }
    typeof rm === 'object' && rm.mode(cachedMode === 'dark' && isDarkMode)
}
initTheme()</script><!-- global head--><script>const GLOBAL_CONFIG = {
    root: '/',
    algolia: undefined,
    localsearch: undefined,
    runtime: '2025-01-01 00:00:00',
    lazyload: {
        enable: false,
        error: '/img/error_load.avif'
    },
    copyright: false,
    highlight: {"limit":200,"expand":true,"copy":true,"syntax":"highlight.js"},
    randomlink: false,
    lang: {"theme":{"dark":"已切换至深色模式","light":"已切换至浅色模式"},"copy":{"success":"复制成功","error":"复制失败"},"backtop":"返回顶部","time":{"day":"天前","hour":"小时前","just":"刚刚","min":"分钟前","month":"个月前"},"day":" 天","f12":"开发者模式已打开，请遵循GPL协议。","totalk":"无需删除空行，直接输入评论即可"},
    aside: {
        sayhello: {
            morning: "✨ 早上好，新的一天开始了",
            noon: "🍲 午餐时间",
            afternoon: "🌞 下午好",
            night: "早点休息",
            goodnight: "晚安 😴",
        },
        sayhello2: [],
        sayhello3: {
            prefix: '好久不见，',
            back: '欢迎再次回来，',
        },
    },
    covercolor: {
        enable: false
    },
    comment: false,
    lightbox: 'null',
    post_ai: false,
    right_menu: false,
    translate: {"translateDelay":0,"defaultEncoding":2},
    lure: false,
    expire: false,
};</script><!-- page-config head--><script id="config-diff">var PAGE_CONFIG = {
    is_post: true,
    is_page: false,
    is_home: false,
    page: '',
    toc: true,
    comment: false,
    ai_text: false,
    color: false,
}</script><meta name="generator" content="Hexo 7.3.0"></head><body id="body"><!-- universe--><!-- background img--><!-- loading--><!-- console--><!-- sidebar--><div id="sidebar" style="zoom: 1;"><div id="menu-mask" style="display: none;"></div><div id="sidebar-menus"><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a></div></div></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><span class="darkmode_switchbutton menu-child" onclick="sco.switchDarkMode()"><i class="solitude fa-solid fa-circle-half-stroke"></i><span>显示模式</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  fas fa-folder-closed"></i><span>全部文章</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  fas fa-clone"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  fas fa-tags"></i><span>全部标签</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-widget card-tags card-archives card-webinfo card-allinfo"><div class="card-tag-cloud"><a href="/tags/%E5%A4%8D%E4%B9%A0/">复习<sup>3</sup></a></div></div><span class="sidebar-menu-item-title">网站信息</span><div class="webinfo"><div class="webinfo-item"><div class="webinfo-item-title"><i class="item-icon solitude fa-solid fa-file-word"></i><div class="item-name">全站字数 :</div></div><div class="item-count">26.9k</div></div></div></div></div><!-- keyboard--><!-- righhtside--><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav class="show" id="nav"><div id="nav-group"><div id="blog_name"><a id="site-name" href="/" title="返回博客主页"><span class="title">Wawa</span><i class="solitude fa-solid fa-home"></i></a></div><div id="page-name-mask"><div id="page-name"><a id="page-name-text" onclick="sco.toTop()">操作系统复习整理</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  fas fa-folder-closed"></i><span>全部文章</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  fas fa-clone"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  fas fa-tags"></i><span>全部标签</span></a></li></ul></div></div></div><div id="nav-left"></div><div id="nav-right"><div class="nav-button" id="nav-totop" onclick="sco.toTop()"><a class="totopbtn"><i class="solitude fa-solid fa-arrow-up"></i><span id="percent">0</span></a></div><div id="toggle-menu"><a class="site-page"><i class="solitude fa-solid fa-bars"></i></a></div></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><article class="post-content article-container"><h1 id="操作系统复习整理"><a href="#操作系统复习整理" class="headerlink" title="操作系统复习整理"></a>操作系统复习整理</h1><h2 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h2><h3 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h3><ul>
<li>命令行界面(Command-Line Interface, CLI)</li>
<li>图形用户界面(Graphic-User Interface, GUI)</li>
</ul>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>内核提供一系列具备预定功能的多内核函数，通过一组称为<strong>系统调用</strong>(System call)的接口呈现给用户。系统调用把应用程序的请求传给内核，调用相应的内核函数完成所需的处理，并将处理结果返回给应用程序。</p>
<p>系统调用的工作过程：运行时支持系统（由编译器直接提供的函数库）提供了系统调用接口(System-call Interface)，以链接到操作系统的系统调用。系统调用接口截取API函数的调用，并调用操作系统中的所需系统调用。通常，每个系统调用都有一个相关数字，而系统调用接口会根据这些数字来建立一个索引列表。系统调用接口就可调用操作系统内核中的所需系统调用，并返回系统调用状态与任何返回值。<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.png" alt="应用程序调用系统调用"></p>
<blockquote>
<p>&#x3D;&#x3D;系统调用与API的区别&#x3D;&#x3D;：<br>系统调用是操作系统提供给用户程序与内核交互的接口，用于完成底层资源管理和硬件操作（如文件操作、进程管理等）；API是用户程序调用的高层接口，通常由库函数或框架提供，用于实现特定功能。</p>
<ul>
<li>作用层次：系统调用位于操作系统内核层，提供直接访问操作系统功能的接口；API位于用户空间，提供对操作系统功能的高层抽象。</li>
<li>调用方式：系统调用需要从用户态切换到内核态，开销较大；API运行在用户态，开销较小。</li>
<li>关系：API通常通过封装系统调用实现高层功能，但也可以在用户空间独立实现</li>
</ul>
</blockquote>
<p>向系统传递参数：</p>
<ul>
<li>通过寄存器传参，适用于参数较少时</li>
<li>参数比较多的时候，存在内存中，内存地址通过寄存器传递</li>
<li>通过程序压入堆栈，并提供操作系统弹出</li>
</ul>
<h3 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h3><ul>
<li>整体式结构</li>
<li>层次式结构</li>
<li>微内核结构<ul>
<li>大内核系统将操作系统的主要功能模块都作为一个紧密联系的整体运行在内核态，从而为应用提供高性能的系统服务。因为各管理模块之间共享信息，能有效利用相互之间的有效特性，所以具有无可比拟的性能优势。</li>
<li>微内核结构将内核中最基本的功能保留在内核，而将那些不需要在内核态执行的功能移到用户态执行，从而降低了内核的设计复杂性。而那些移出内核的操作系统代码根据分层的原则被划分成若干服务程序，它们的执行相互独立，交互则都借助于微内核进行通信。<ul>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E5%BE%AE%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84.png" alt="微内核结构"><blockquote>
<ul>
<li>&#x3D;&#x3D;优点&#x3D;&#x3D;：解决操作系统的内核代码难以维护的问题，降低了内核的设计复杂性，实现高可靠性。模块中的错误虽然会使模块崩溃，但不会让整个系统死机。应用于实时、工业、航空、军事</li>
</ul>
</blockquote>
</li>
<li>缺点：性能问题，频繁在核心态和用户态之间切换，造成操作系统的执行开销偏大</li>
<li>Windows、Mac</li>
<li><strong>低级存储管理</strong>：把每个虚拟页映射到一个物理页框，存储管理的大部分功能，包括保护一个进程的地址空间免于另一个进程的干涉</li>
<li><strong>进程间通信</strong>(IPC)：进程之间或线程之间进行通信的基本形式是消息，基于进程间相关联的端口</li>
<li><strong>I&#x2F;O</strong></li>
<li><strong>中断管理</strong>：识别但不处理</li>
</ul>
</li>
</ul>
</li>
<li>模块化结构<ul>
<li>利用面向对象编程技术来生成模块化的内核</li>
<li>Linux</li>
<li>将内核镜像的尺寸保持在最小，并具有最大的灵活性；便于检验新的内核代码，而不需重新编译内核并重新引导。</li>
</ul>
</li>
</ul>
<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>每一台虚拟机都是在Hypervisor的基础上建立起来的。Hypervisor是一种运行在物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享一套基础物理硬件，因此也可以看作是虚拟环境中的“元”操作系统：它可以协调访问服务器上的所有物理设备和虚拟机，也叫作虚拟机监视器(Virtual Machine Monitor，VMM)。Hypervisor是所有虚拟化技术的核心。非中断地支持多工作负载迁移的能力是Hypervisor的基本功能。当服务器启动并执行Hypervisor时，它会给每一台虚拟机分配适量的内存、CPU、网络和磁盘，并加载所有虚拟机的客户操作系统。</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程基础"><a href="#进程基础" class="headerlink" title="进程基础"></a>进程基础</h3><h4 id="程序的顺序执行和并发执行"><a href="#程序的顺序执行和并发执行" class="headerlink" title="程序的顺序执行和并发执行"></a>程序的顺序执行和并发执行</h4><ul>
<li><strong>顺序执行</strong>：系统所有资源被这个程序独占，具有顺序性、封闭性、可再现性的特点</li>
<li><strong>并发执行</strong>：共享和竞争资源</li>
</ul>
<h4 id="进程的定义与特征"><a href="#进程的定义与特征" class="headerlink" title="进程的定义与特征"></a>进程的定义与特征</h4><p><strong>进程</strong>是并发执行的程序在一个数据集上的执行过程，是系统分配资源和调度的基本单位。</p>
<ul>
<li>动态性。进程是程序在并发系统内的一次执行，一个进程有一个产生到消失的生命周期。</li>
<li>并发性。正是为了描述程序在并发系统内执行的动态特性才引入了进程，没有并发就没有进程。</li>
<li>独立性。每个进程的实体是一个能独立运行、独立获得资源、独立调度的基本单位。</li>
<li>异步性。进程按各自独立的、不可预知的速度向前推进，并按异步方式运行。</li>
</ul>
<p>进程与程序的<strong>区别</strong>在于：</p>
<ul>
<li>进程是一个动态的实体，有生命期，由创建而产生，由调度而执行，由撤销而消亡：而程序是一个静态的实体，只是一组指令的有序集合。如果把程序比作一个剧本，那么进程就是这个剧本的一次演出。</li>
<li>进程具有并发性，各进程的执行是独立的，执行速度是异步的；而程序是不能并发执行的。</li>
<li>进程具有独立性，是一个能独立运行的基本单位。没有建立进程的程序是不能作为独立的单位参与运行的。</li>
</ul>
<p><strong>进程控制块PCB</strong>记录了操作系统所需的、用于描述并控制进程运行所需的所有信息，包括进程的<strong>描述信息、控制信息和资源信息</strong>。操作系统通过进程控制块来感知进程的存在，掌握其所处的状态以达到管理和控制进程的目的。<br><strong>进程标识符</strong>用于唯一地识别一个进程。<br>进程是由一段<em>可执行的程序</em>、<em>数据</em>（程序数据、用户栈以及可修改的程序）、<em>系统栈</em>（用于保存参数、过程调用地址以及系统调用地址）以及<em>进程控制块PCB</em>组成的集合，该集合也可称为<strong>进程映像</strong>。<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/PCB&%E8%BF%9B%E7%A8%8B%E6%98%A0%E5%83%8F.png" alt="PCB&amp;进程映像"><br>通过对进程控制块PCB的存取，操作系统为进程分配资源，进行调度。当进程被调度执行时，系统按PCB中程序计数器指出的地址执行程序；当进程被中断时，操作系统会将程序计数器和处理器寄存器（上下文数据）保存于PCB中，并修改进程状态（阻塞或就绪）；通过修改PCB中的状态为运行态，并将PCB中的程序计数器和进程上下文数据加载到处理器寄存器中，使进程恢复运行；当进程执行结束后，通过释放PCB来释放进程占有的各种资源。</p>
<h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><ul>
<li><strong>初始态</strong>：进程刚被创建时，处于初始状态，系统己经为它创建了PCB，但还未加载到内存中。</li>
<li><strong>终止态</strong>：进程执行结束或被取消，但其PCB等信息还未释放。</li>
<li><strong>运行态</strong>：进程占有处理器，正在执行。</li>
<li><strong>阻塞态</strong>：进程等待某个时间的发生。</li>
<li><strong>就绪态</strong>：具备执行的所有条件，等待系统分配处理器后执行。进程在它的生命期里的状态会不断发生变化。</li>
</ul>
<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%94%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81.png" alt="进程的五种基本状态"></p>
<p>当内存中的进程都在等待I&#x2F;O，同时内存容量又不足以容纳更多新进程时，处理器处于空闲状态。解决该问题的办法是交换，即将内存中某个进程的一部分或全部换出到磁盘，使它处于“<strong>挂起</strong>”状态，然后接受一个新进程的请求，将其装入内存运行。<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%9C%89%E6%8C%82%E8%B5%B7%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" alt="有挂起的进程状态转换图"></p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><ul>
<li><strong>系统态&#x2F;控制态&#x2F;内核态</strong>：具有对处理器以及所有指令、寄存器和内存的控制能力</li>
<li><strong>用户态</strong>：只能执行规定的指令，访问指定的寄存器和存储区</li>
</ul>
<p>系统进程运行在系统态，用户进程运行在用户态。</p>
<h4 id="进程的创建与终止"><a href="#进程的创建与终止" class="headerlink" title="进程的创建与终止"></a>进程的创建与终止</h4><ul>
<li><strong>进程创建</strong><ol>
<li>给新进程分配一个唯一的进程标识符(<strong>pid</strong>)，并申请一个空白的PCB（PCB是有限的）。若PCB申请失败，则创建失败。</li>
<li>给进程分配空间分配包括程序、数据、用户栈等。</li>
<li>将新进程插入就绪队列和进程隶属关系族群中。</li>
<li>创建或扩充其他数据结构，如为进程创建记账文件等。</li>
</ol>
</li>
<li><strong>进程撤销</strong><ol>
<li>从PCB队列中检索到被终止进程的PCB，并修改其状态。</li>
<li>若该进程有子孙进程，则应将其所有子孙进程终止。</li>
<li>释放该进程的所有资源。</li>
<li>将该进程的PCB从系统PCB队列中删除。</li>
</ol>
</li>
<li><strong>进程阻塞</strong><ol>
<li>停止运行，修改PCB中状态为“阻塞”。</li>
<li>将进程插入阻塞队列。如果系统设置了多个不同原因的阻塞队列，则将进程插入到具有相同原因的阻塞队列中。</li>
<li>系统进行调度并完成进程切换。保留被阻塞进程的处理器状态于PCB中，转操作系统调度程序，选择一个就绪进程将处理器分配给它，并按新进程PCB中的处理器状态设置CPU环境，完成进程切换。</li>
</ol>
</li>
<li><strong>进程唤醒</strong><ol>
<li>把被阻塞的进程从等待该事件的阻塞队列中移出，唤醒原语将进程从外存调入内存。</li>
<li>将其PCB中的现行状态由阻塞改为就绪，然后再将该PCB插入到就绪队列中。</li>
<li>假如采用的是抢占调度策略，则每当有新进程进入就绪队列时，检查是否要进行重新调度，即比较被唤醒进程与当前进程的优先级，决定处理机的归属。</li>
</ol>
</li>
</ul>
<p>进程进入等待(阻塞)的情况：</p>
<ul>
<li>请求并等待系统服务，无法马上完成</li>
<li>启动某种操作，无法马上完成</li>
<li>需要的数据没有到达</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程又被称为轻型进程，在引入了线程的系统中，线程是一个可以独立行和调基本单位，但不再是拥有资源的独立单位。它只拥有少量运行中必不可少的资源（如程序计数器、一组寄存器和栈），它可与同属一个进程的线程<em>共享</em>该进程拥有的所有资源。</p>
<blockquote>
<p>&#x3D;&#x3D;进程和线程的区别和联系&#x3D;&#x3D;</p>
<ul>
<li>在引入了线程的系统中，线程是作为调度和分派的基本单位，而进程是作为资源分配的基本单位。同一进程中的线程切换不会引起进程切换。</li>
<li>在引入了线程的系统中，不仅进程之间可以并发执行，而且一个进程的多个线程之间也可以并发执行，因此可以更有效地使用系统资源，具有更好的并发性。</li>
<li>进程是拥有资源的独立单位，而线程只拥有少量的资源，但它可以访问其隶属进程的资源。因此，线程创建、终止和切换时的系统开销比进程小。</li>
<li>由于同一进程的线程共享内存和文件，因此在同一个地址空间里，它们之间的通信无需调用内核，从而提高了通信的效率。</li>
</ul>
</blockquote>
<ul>
<li>用户级线程与内核级线程<ul>
<li><strong>内核级线程</strong>： 线程管理的所有工作都是由内核完成的。用户通过操作系统给应用程序提供的应用程序编程接口API来进行进程管理。<ul>
<li>可以将同一进程的多个线程调度到不同的处理器上并行执行。如果一个进程中的一个线程被阻塞，内核可以调度同一进程中的多个线程运行。</li>
<li>内核程序本身也可以使用多线程，从而可以提高操作系统内核程序执行的效率。</li>
<li>当把控制从一个线程转到同一进程的另一个线程时，需要内核参与，处理器状态首先从用户态转到内核态，系统调用结束后，再切换回用户态。</li>
</ul>
</li>
<li><strong>用户级线程</strong>：线程管理的所有工作都是由应用程序完成的，内核意识不到线程的存在，内核以进程为单位进行调度。操作系统提供给用户一个线程库对线程进行操作。<ul>
<li>优点<ul>
<li>由于所有线程管理数据都在进程的用户地址空间中，所以线程切换不需要内核参与，节省了模式切换的开销。</li>
<li>线程的调度算法和调度过程都由用户自行选择，与操作系统内核无关。因为操作系统调度的单位是进程，在进程内部，用户可根据需要设置线程调度算法。</li>
<li>用户级线程可以在任何操作系统中运行，不需对底层内核进行修改。因为线程库是一组应用程序级别函数。</li>
</ul>
</li>
<li>缺点<ul>
<li>当一个用户级线程因调用一个系统调用而阻塞时，其所属的进程中的所有线程都会被阻塞。</li>
<li>一个多线程应用程序无法使用多处理器技术，因为内核只为进程分配一个处理器，所以一个进程中只有一个线程能够执行，一个进程中的多个线程无法并行执行。</li>
</ul>
</li>
</ul>
</li>
<li><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B.png" alt="用户级线程和内核级线程"></li>
</ul>
</li>
</ul>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="进程的互斥"><a href="#进程的互斥" class="headerlink" title="进程的互斥"></a>进程的互斥</h3><p><strong>临界资源</strong>：在某段时间内只允许一个进程使用的资源<br><strong>临界区</strong>：使用临界资源的部分程序<br>访问临界资源的进程可描述为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    进入区</span><br><span class="line">        临界区</span><br><span class="line">    退出区</span><br><span class="line">        剩余区</span><br><span class="line">&#125; <span class="keyword">while</span>(TRUE)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>系统需满足：</p>
<ul>
<li>互斥：一次最多一个进程能够进入临界区，当有进程在临界区执行时，其他进程若想要进入临界区，则需要等待。</li>
<li>有限等待：不能让一个进程无限制地在临界区内执行，即任意进入临界区的进程必须在有限时间内退出临界区。</li>
<li>空闲让进：如果某进程退出临界区，而有其他进程正在等待进入临界区时，应当让这个程序进入。</li>
</ul>
</li>
<li><p>使用<strong>硬件</strong>实现互斥</p>
<ul>
<li>中断禁用</li>
<li>专用机器指令</li>
</ul>
</li>
<li><p>使用<strong>信号量</strong>实现互斥</p>
<ul>
<li>基本原理：两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫在某一位置停止，直到它接收到一个特定的信号。</li>
<li>当信号量s.value的值为非负整数时，表示某类可用资源的数目；当信号量s.value的值为负整数时，则s.value的绝对值等于由于请求该资源而被阻塞的进程的总数。</li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QUEUETYPE</span> *<span class="title">queue</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(semaphore s)</span></span><br><span class="line">&#123;</span><br><span class="line">    s.value = s.value - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.value &lt; <span class="number">0</span>)</span><br><span class="line">        block(s.<span class="built_in">queue</span>); <span class="comment">// 将进程阻塞，并将其投入等待队列s.queue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(semaphore s)</span></span><br><span class="line">&#123;</span><br><span class="line">    s.value = s.value + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.value &lt;= <span class="number">0</span>)</span><br><span class="line">        wakeupWait(s.<span class="built_in">queue</span>); <span class="comment">// 唤醒被阻塞进程，并将其从等待队列s.queue取出，投入就绪队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="进程的同步"><a href="#进程的同步" class="headerlink" title="进程的同步"></a>进程的同步</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E5%90%8C%E6%AD%A5%E5%85%B3%E7%B3%BB.png" alt="同步关系"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Semaphore Bufempty, Buffull;</span><br><span class="line">Bufempty.value = n; Buffull.value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">A</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    wait(Bufempty); <span class="comment">//按照FIFO方式选择一个空闲缓冲区</span></span><br><span class="line">    save(data);</span><br><span class="line">    signal(Buffull);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">B</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    wait(Buffull); <span class="comment">//按照FIFO方式选择一个装满数据的缓冲区</span></span><br><span class="line">    retrieve(data);</span><br><span class="line">    signal(Bufempty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    parbegin(A, B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%89%8D%E9%A9%B1%E5%90%8E%E7%BB%A7.png" alt="进程的前驱后继"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Semaphore S_12, S_13, S_24, S_25, S_36, S_46, S_56;</span><br><span class="line">S_12 = S_13 = S_24 = S_25 = S_36 = S_46 = S_56 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">S_1</span><span class="params">()</span>&#123; S_1 execute; signal(S_12); signal(S_13); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">S_2</span><span class="params">()</span>&#123; wait(S_12); S_2 execute; signal(S_24); signal(S_25); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">S_3</span><span class="params">()</span>&#123; wait(S_13); S_3 execute; signal(S_36);&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">S_4</span><span class="params">()</span>&#123; wait(S_24); S_4 execute; signal(S_46); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">S_5</span><span class="params">()</span>&#123; wait(S_25); S_5 execute; signal(S_56); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">S_6</span><span class="params">()</span>&#123; wait(S_36); wait(S_46); wait(S_56); S_6 execute; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h3><ul>
<li>共享内存<ul>
<li>注意多个进程之间对一个给定存储区访问的互斥，用户程序自己解决（信号量）</li>
</ul>
</li>
<li>管道通信<ul>
<li>互斥。当一个进程正在对管道进行读或写操作时，另一个进程必须等待。</li>
<li>同步。管道的大小是有限的，所以当管道满时，写进程必须等待，直到读进程把它唤醒为止。同理，当管道没有数据时，读进程也必须等待，直到写进程将数据写入管道后，读进程才被唤醒。</li>
<li>确认对方是否存在。只有确认对方存在时，才能进行通信。</li>
</ul>
</li>
<li>消息传递通信<ul>
<li>消息队列</li>
</ul>
</li>
</ul>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>把分散在各进程中的临界区集中起来进行管理，防止进程有意或无意的违法同步操作。<br>一个管程定义了一个数据结构和在该数据结构上能为并发进程所执行的一组操作，这组操作能同步进程和改变管程中的数据。<br>管程在结构上由以下三部分组成：</p>
<ul>
<li>管程所管理的共享数据结构。这些数据结构是对应临界资源的抽象。</li>
<li>建立在该数据结构上的一组操作。</li>
<li>对上述数据结构进行初始化的语句。</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="&#x3D;&#x3D;死锁产生的必要条件&#x3D;&#x3D;"></a>&#x3D;&#x3D;死锁产生的必要条件&#x3D;&#x3D;</h3><blockquote>
<ul>
<li><strong>互斥条件</strong>。互斥条件指进程的共享资源必须保持使用的互斥性，即任何一个时刻只能分配给一个进程使用。互斥条件是形成死锁最根本的原因，因为如果资源不要求排它性地使用，那么一定不会造成请求资源而无法满足的局面。</li>
<li><strong>占有且等待条件</strong>。一个进程占有了某些资源之后又要申请新的资源而得不到满足时，处于等待资源的状态，且不释放己经占用的资源。</li>
<li><strong>不可剥夺条件</strong>。任何进程不能抢夺另一个进程所占用的资源，即己经被占用的资源只能由占用进程自己来释放。</li>
<li><strong>环路条件</strong>。存在一组进程 P1，P2，···，Pn，其中每个进程分别等待另一个进程所占用的资源，形成环路等待条件。</li>
</ul>
</blockquote>
<h3 id="死锁的处理方法"><a href="#死锁的处理方法" class="headerlink" title="死锁的处理方法"></a>死锁的处理方法</h3><h4 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h4><ul>
<li>破坏互斥</li>
<li>禁止占用且等待<ul>
<li>进程开始前申请全过程需要的全部资源</li>
<li>进程开始前仅获取初期需要的资源，运行过程中释放分配到的、已经使用完毕的资源，再请求新的资源</li>
</ul>
</li>
<li>废除“不可抢占”条件</li>
<li>破坏循环等待条件</li>
</ul>
<h4 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h4><p>死锁的避免采用的是资源分配拒绝策略，又称为<strong>银行家算法</strong>。在该方法中，允许进程动态地申请资源，但是系统在进行资源分配之前，先计算资源分配的安全性，如果此次分配不会导致系统进入不安全状态，便将资源分配给进程，否则不予以分配，进程只能等待。<br>安全状态就是指至少存在一个安全序列&lt;P1, P2, … , Pn&gt; ，按照这个序列为进程分配所需的资源，直到满足最大需求，使得每个进程都可以顺利完成。若系统不存在这样一个安全序列，则称为系统处于不安全状态。<br>虽然并非所有不安全状态都是死锁状态，但是系统进入不安全状态后，便可能进入死锁状态：反之，只要系统处于安全状态，系统便可以避免死锁。因此，避免死锁的实质在于：<strong>如何使系统不进入不安全状态</strong>。</p>
<h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><ul>
<li>单体资源<ul>
<li>构建资源分配图，不存在环则不存在死锁</li>
</ul>
</li>
<li>多体资源<ul>
<li>银行家算法</li>
</ul>
</li>
</ul>
<h4 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h4><ul>
<li>撤销所有的死锁进程</li>
<li>把每个死锁的进程恢复到前面定义的某个检查点，并重新运行这些进程</li>
<li>有选择地撤销死锁过程，直到不存在死锁</li>
<li>剥夺资源，直到不存在死锁</li>
</ul>
<h2 id="处理器调度"><a href="#处理器调度" class="headerlink" title="处理器调度"></a>处理器调度</h2><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><ul>
<li>非抢占式调度策略：一旦进程处于运行状态，它不断运行，直到运行结束或运行至阻塞时进行调度。即当运行进程主动释放CPU时，才执行调度程序。</li>
<li>抢占式调度策略：当前正在运行的程序可能被系统中断，转为就绪态。抢占的发生可能是在一个高优先级进程到达时，或在一个中断发生后一个阻塞的进程变为就绪时，或者基于周期性的时间中断（时间片）时。</li>
</ul>
<h3 id="分级调度"><a href="#分级调度" class="headerlink" title="分级调度"></a>分级调度</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E8%B0%83%E5%BA%A6%E8%BD%AC%E6%8D%A2.png" alt="调度转换"></p>
<ul>
<li>长程调度（作业调度）<ul>
<li>限制系统的并发度</li>
<li>先来先服务FCFS、最短作业优先SJF、最高响应比优先HRRN</li>
</ul>
</li>
<li>中程调度<ul>
<li>提高内存利用率和系统吞吐量</li>
</ul>
</li>
<li>短程调度（进程调度）</li>
</ul>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="先来先服务-First-Come-First-Served-FCFS-调度算法"><a href="#先来先服务-First-Come-First-Served-FCFS-调度算法" class="headerlink" title="先来先服务(First Come First Served, FCFS)调度算法"></a>先来先服务(First Come First Served, FCFS)调度算法</h4><p>它按照请求CPU的顺序分配CPU。新就绪的进程依次排在就绪队列尾部，当CPU空闲时，调度排在就绪队列头部的进程。</p>
<h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><p>动态优先级：与进程占有CPU时间的长短成反比，与在就绪队列中等待的时间成正比</p>
<h4 id="最短作业优先-Shortest-Job-First-SJF-调度算法"><a href="#最短作业优先-Shortest-Job-First-SJF-调度算法" class="headerlink" title="最短作业优先(Shortest Job First, SJF)调度算法"></a>最短作业优先(Shortest Job First, SJF)调度算法</h4><p>难点在于如何知道下次CPU执行的长度，常用于长程调度（作业调度），不常用于进程调度<br>基于抢占式的SJF：最短剩余时间优先调度算法，通过比较当前就绪队列中进程的剩余时间和新到的进程所需的时间进行调度<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88.png" alt="最短剩余时间优先"></p>
<h4 id="最高响应比优先-Highest-Response-Ratio-Next-HRRN-调度算法"><a href="#最高响应比优先-Highest-Response-Ratio-Next-HRRN-调度算法" class="headerlink" title="最高响应比优先(Highest Response Ratio Next, HRRN)调度算法"></a>最高响应比优先(Highest Response Ratio Next, HRRN)调度算法</h4><p><code>R = (W + S) / S</code><br><code>W为等待时间，S为预计的执行时间</code><br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/HRRN_1.png" alt="HRRN_1"><br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/HRRN_2.png" alt="HRRN_2"></p>
<h4 id="轮转-RR-调度算法"><a href="#轮转-RR-调度算法" class="headerlink" title="轮转(RR)调度算法"></a>轮转(RR)调度算法</h4><p>调度程序按就绪队列中进程的顺序依次调度进程运行，每个进程每次运行一个时间片，时间片结束时，正运行的进程对 CPU的拥有权被剥夺，状态由运行转为就绪，重新排在就绪队列末尾等、下一次调度，CPU被分配给下一个就绪进程。<br>通常应用于分时系统</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存空间连续分配方案"><a href="#内存空间连续分配方案" class="headerlink" title="内存空间连续分配方案"></a>内存空间连续分配方案</h3><ul>
<li><p>单一连续分配</p>
</li>
<li><p>固定分区分配</p>
<ul>
<li>大小固定</li>
<li>大小不等</li>
</ul>
</li>
<li><p>动态分区分配</p>
<ul>
<li>首次适应(First Fit)<ul>
<li>空闲分区以地址递增的顺序链接，系统分配内存时按顺序查找，找到第一个能满足要求的空闲分区</li>
</ul>
</li>
<li>最佳适应(Best Fit)<ul>
<li>空闲分区按容量大小递增形成分区链</li>
</ul>
</li>
<li>最坏适应(Worst Fit)<ul>
<li>空闲分区按容量大小递减形成分区链</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">算法思想</th>
<th align="center">分区排列顺序</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">首次适应算法</td>
<td align="center">从头到尾找适合的分区</td>
<td align="center">空闲分区以地址递增次序排列</td>
<td align="center">综合看性能最好。算法开销小，回收分区后一般不需要对空闲分区队列重新排序</td>
<td align="center">低地址段可能会出现许多小碎片</td>
</tr>
<tr>
<td align="center">最佳适应算法</td>
<td align="center">优先使用更小的分区，以保留更多大分区</td>
<td align="center">空闲分区以容量大小递增次序排列</td>
<td align="center">会有更多的大分区被保留下来，能满足大进程需求</td>
<td align="center">会产生很多太小的、难以利用的碎片；算法开销大，回收分区后可能需要对空闲分区队列重新排序</td>
</tr>
<tr>
<td align="center">最坏适应算法</td>
<td align="center">优先使用更大的分区，以防止产生太小的不可用的碎片</td>
<td align="center">空闲分区以容量大小递减次序排列</td>
<td align="center">算法查找效率高，不用每次都从低地址的小分区开始检索</td>
<td align="center">算法开销大，回收分区后可能需要对空闲分区队列重新排序；使存储器中缺乏大的空闲分区</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="分页存储管理"><a href="#分页存储管理" class="headerlink" title="分页存储管理"></a>分页存储管理</h3><p>分页存储管理将进程的逻辑地址空间分成若干个大小相等的页面（虚页），相应地，也把内存的物理地址空间分成若干个页帧（页框），页帧大小与虚页的大小相等。<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86.png" alt="页式存储管理"><br>每个进程有一张页表，在进程地址空间内所有页依次在页表中有一页表项，记录了相应页在内存中对应的页帧号。页表的作用是<strong>实现从页号到页帧号的地址映射</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">假设某系统物理内存大小为4GB，页面大小为4KB，则每个页表项至少应该为多少字节？</span><br><span class="line">由于4GB = 2^32 B，4KB = 2^12 B，因而4GB的内存总共会被分为2^32 / 2^12 = 2^20个内存块，内存页帧号的范围应该是0 ~ 2^20 - 1，</span><br><span class="line">因此至少要20个二进制位才能表示这么多的内存页帧号，故每个页表项至少要3个字节才够（每个字节8个二进制位）</span><br><span class="line">各页表项会按顺序存放在内存中，如果该页表在内存中存放的起始地址为X，则M号页面对应的页表项是存放在内存地址，为X + 3 * M。</span><br></pre></td></tr></table></figure>
<h4 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h4><ul>
<li>基本页式地址变换机构<ul>
<li>在系统中只设置一个页表寄存器PTR(Page-Table Register)，其中存放<strong>页表在内存的始址</strong>和<strong>页表的长度</strong>。程序未执行时，页表的始址和页表长度存放在本进程的PCB中。当调度程序调度到该进程时，才将这两个数据装入页表寄存器中。</li>
<li>虚地址结构<br>  <img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E8%99%9A%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png" alt="虚地址结构"><br>  <img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E5%9F%BA%E6%9C%AC%E9%A1%B5%E5%BC%8F%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E7%BB%93%E6%9E%84.png" alt="基本页式地址变换结构"></li>
</ul>
</li>
<li>具有快表的地址变换机构<ul>
<li>为了提高地址变换速度，可在地址变换机构中增设一个专用且快速的硬件缓冲器（又称为“联想寄存器”或“快表”），在IBM系统中又取名为TLB，用来存放最近访问的那些页表项。</li>
<li>若在快表中未找到对应的页表项，则还需再访问内存中的页表，同时需要将此页表项写入到快表中（修改快表）。如果联想寄存器己满，则需要淘汰一个表项并进行置换。</li>
<li>假定访问一次内存的时间为t，查找快表所需要的时间为λ，快表的命中率为a，内存的有效访问时间为 EAT，则：<ul>
<li>基本页式地址变换机构： <code>EAT = 2t</code></li>
<li>具有快表的地址变换机构: <code>EAT = (λ + t)a + (λ + 2t)(1 - a) = 2t + λ - at</code><br>  <img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84.png" alt="具有快表的地址变换机构"></li>
</ul>
</li>
</ul>
</li>
<li>两级页表<br>  <img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80.png" alt="两级页表的逻辑地址"><br>  <img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="两级页表结构"></li>
</ul>
<h3 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h3><p>地址空间由若干个逻辑分段组成，每一个分段是一组逻辑意义完整的信息集合，并且有自己名字（段名），每一段都是以0开始的连续的一维地址空间：整个进程的地址空间是二维的，由<strong>段号</strong>与<strong>段内位移量</strong>（段内地址）组成。<br>每个进程有一张段表，每个段在表中有一个表项，包括段号、段长和内存起始地址。段表的主要功能是<strong>实现逻辑段到内存空间之间的映射</strong>。<br><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%AE%B5%E5%BC%8F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" alt="段式地址空间"></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">分页</th>
<th align="center">分段</th>
</tr>
</thead>
<tbody><tr>
<td align="center">管理思想</td>
<td align="center">页是信息的物理单位，是为了管理主存的方便而划分的：页的大小固定不变，实现了程序的非连续存放</td>
<td align="center">段是信息的逻辑单位，是根据用户的需要划分的；段的大小是不固定的，是山其完成的功能决定。因此，段对用户是可见的</td>
</tr>
<tr>
<td align="center">虚地址</td>
<td align="center">页式向用户提供的是一维地址空间，页号和页内偏移是机器硬件的功能</td>
<td align="center">段式向用户提供的是二维地址空间</td>
</tr>
<tr>
<td align="center">共享与存储访问控制</td>
<td align="center">可以实现页面共享，但使用受到诸多限制，访问控制困难</td>
<td align="center">便于共享逻辑完整的信息，易于实现存取访问权限控制</td>
</tr>
<tr>
<td align="center">动态链接</td>
<td align="center">不支持动态链接</td>
<td align="center">支持动态链接</td>
</tr>
</tbody></table>
<blockquote>
<p>&#x3D;&#x3D;分段比分页更容易实现进程共享和保护的原因&#x3D;&#x3D;</p>
<ul>
<li>分段：将内存按逻辑单元划分为段（如代码段、数据段），每个段有独立的基址和长度。分页：将内存划分为固定大小的页，与程序逻辑无关。</li>
<li><strong>逻辑划分更直观</strong>：分段基于程序的逻辑结构（如代码段、数据段），天然支持特定段的共享（如多个进程共享代码段），而分页与逻辑无关，需额外设计页表映射。</li>
<li><strong>保护机制更灵活</strong>：分段通过段表设置每个段的基址、长度和访问权限（读、写、执行），可以精确保护不同逻辑单元。分页只能以固定大小的页为单位设置权限，灵活性较低。</li>
<li><strong>共享机制更简单</strong>：分段共享某段时，只需将段的基址和长度加入另一个进程的段表。分页需要复杂的页表操作，且需确保地址对齐</li>
</ul>
</blockquote>
<h3 id="虚拟存储技术"><a href="#虚拟存储技术" class="headerlink" title="虚拟存储技术"></a>虚拟存储技术</h3><h4 id="请求分页存储管理"><a href="#请求分页存储管理" class="headerlink" title="请求分页存储管理"></a>请求分页存储管理</h4><ul>
<li>请求分页的页表机制<br>  <img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%89%A9%E5%B1%95%E5%90%8E%E7%9A%84%E9%A1%B5%E8%A1%A8.png" alt="扩展后的页表"><ul>
<li>页帧号：指出该页在主存中的占用的页帧号。</li>
<li>状态位：指出该页是否己经调入主存（通常1表示己在内存，0表示未载入内存）。</li>
<li>访问位：记录该页是否被访问（通常1表示己访问，0表示未访问）。</li>
<li>修改位：表示该页调入主存后是否被修改（通常1表示发生修改，0表示未发生修改）。判断该页是否回写的依据。</li>
<li>辅存地址：指示该页在磁盘上的地址。</li>
</ul>
</li>
<li>缺页中断机构<ul>
<li>在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否在内存中。每当所要访问的页面不在内存时，会发生缺页错误，因此产生一个<strong>缺页中断</strong>，此时操作系统会根据页表中的辅存地址在外存中找到所缺的一页，将其调入内存。</li>
<li>与一般中断的区别<ul>
<li>在指令执行期间产生和处理缺页中断信号。</li>
<li>一条指令在执行期间，可能产生多次缺页中断。</li>
<li>缺页中断返回时，执行产生中断的那一条指令：而一般的中断返回时，执行下一条指令。</li>
</ul>
</li>
</ul>
</li>
<li>地址变换机构<br>  <img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%BC%BA%E9%A1%B5%E5%A4%84%E7%90%86.png" alt="地址变换与缺页处理"></li>
</ul>
<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><h5 id="先进先出-FIFO-页面置换算法"><a href="#先进先出-FIFO-页面置换算法" class="headerlink" title="先进先出(FIFO)页面置换算法"></a>先进先出(FIFO)页面置换算法</h5><p>总是选择在主存中停留时间最长的页面进行置换。</p>
<h5 id="最优-OPT-页面置换算法"><a href="#最优-OPT-页面置换算法" class="headerlink" title="最优(OPT)页面置换算法"></a>最优(OPT)页面置换算法</h5><p>选择的被淘汰页面是以后永不使用的或在最长时间内不再被访问的。</p>
<h5 id="最久未使用-LRU-页面置换算法"><a href="#最久未使用-LRU-页面置换算法" class="headerlink" title="最久未使用(LRU)页面置换算法"></a>最久未使用(LRU)页面置换算法</h5><p>选择在最近一段时间里最久没有使用过的页面。</p>
<ul>
<li>使用计数器</li>
<li>使用堆栈，最近使用的页面从堆栈中移除并放到顶部</li>
</ul>
<h4 id="页面缓冲算法"><a href="#页面缓冲算法" class="headerlink" title="页面缓冲算法"></a>页面缓冲算法</h4><ul>
<li>空闲页面链表：用于分配给频繁发生缺页的进程，以降低该进程的缺页率。</li>
<li>修改页面链表：为了减少已修改页面换出的次数，减少磁盘I&#x2F;O次数</li>
</ul>
<h4 id="页帧分配算法"><a href="#页帧分配算法" class="headerlink" title="页帧分配算法"></a>页帧分配算法</h4><ul>
<li>平均分配法</li>
<li>按比例分配法：按进程地址空间所占的页面比例分配</li>
</ul>
<h4 id="页帧分配策略"><a href="#页帧分配策略" class="headerlink" title="页帧分配策略"></a>页帧分配策略</h4><p>局部分配策略（同一进程内）&#x2F;全局分配策略（可运行进程间）</p>
<h5 id="系统抖动"><a href="#系统抖动" class="headerlink" title="系统抖动"></a>系统抖动</h5><p>随着进程的增加，CPU的利用率也会增加，但是如果同一时间进程过多，每个进程占用的帧就相应变少，就可能出现进程执行时需要经常性地发生缺页中断、CPU利用率又降低的现象；而这时，操作系统还以为是进程数量太少导致的，还继续加入进程，导致每个进程占用的帧更少、CPU利用率更低的恶性循环，这种现象称为<strong>系统抖动</strong>。</p>
<ul>
<li>原因<ul>
<li>分配的页帧数量太小</li>
<li>置换算法选择不当</li>
</ul>
</li>
<li>解决方法<ul>
<li><strong>工作集策略</strong>：研究一个进程实际使用多少帧。操作系统监视每个进程的工作集，并为它分配大于其工作集的帧数。如果还有足够的额外帧，那么可启动另一进程。如果所有进程工作集大小的总和增加，以致超过内存可用帧的总数，就可能会导致系统抖动，则操作系统会选择一个进程来挂起。该进程的页面被写出（交换），并且其页帧可分配给其他进程。挂起的进程以后可以重启。</li>
<li><strong>缺页率策略</strong>：检测系统中缺页错误的情况。设置所需缺页率的上下限。如果实际缺页率超过上限，则可为进程再分配更多的页帧；如果实际缺页率低于下限，则可从进程中移走页帧。</li>
</ul>
</li>
</ul>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="文件系统层次结构"><a href="#文件系统层次结构" class="headerlink" title="文件系统层次结构"></a>文件系统层次结构</h3><p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="文件系统层次结构"></p>
<ul>
<li><strong>用户接囗</strong>：文件系统为用户提供与文件相关的各种系统调用函数，如新建、打开、读写、关闭、删除文件，建立、删除目录等。此层由若干程序模块组成，每一模块对应一条系统调用，用户发出系统调用时，控制即转入相应的陷阱机构处理执行并返回结果。</li>
<li><strong>文件目录结构</strong>：文件目录结构的主要功能是管理文件目录，其任务有管理活跃文件目录表、管理读写状态信息表、管理用户进程的打开文件表、管理与组织在存储设备上的文件目录结构、调用下一级存取控制模块。</li>
<li><strong>存取控制模块</strong>：文件保护的功能主要由该层软件实现。例如，它把用户的访问要求与文件控制块FCB中指示的访问控制权限进行比较，以确认访问的合法性。</li>
<li><strong>逻辑文件系统与文件信息缓冲区</strong>：逻辑文件系统与文件信息缓冲区的主要功能是根据文件的逻辑结构将用户要读写的逻辑记录转换成文件逻辑结构内的逻辑块号。</li>
<li><strong>物理文件系统</strong>：物理文件系统的主要功能是把逻辑记录所在的逻辑块号转换成实际的物理地址。</li>
<li><strong>辅助分配模块</strong>：辅助分配模块的主要功能是管理辅存空间，即负贵分配辅存空闲空间和回收辅存空间。</li>
<li><strong>设备管理模块</strong>：设备管理模块的主要功能是分配设备、分配读写用缓冲区、磁盘调度、启动设备、处理设备中断、释放设备读写缓冲区、释放设备等。</li>
</ul>
<h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3><ul>
<li>无结构的流式文件：对文件内的信息不再划分单位，依次的一串字符流构成的文件</li>
<li>有结构的记录式文件：用户把文件内的信息按逻辑上独立的含义划分信息单位，每个单位成为一个逻辑记录<ul>
<li><strong>堆结构文件</strong>：按生成的先后顺序排列。有利于记录追加，较好地用于穷举查找，不利于按关键字查找。<br>  <img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E5%A0%86%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6.png" alt="堆结构文件"></li>
<li><strong>顺序结构文件</strong>：记录在文件中按照某个规则排序，通常按照某个关键字排序。</li>
<li><strong>散列结构文件</strong>：使用散列函数将记录的关键字值经过计算转化为记录的逻辑号（记录的编号）。</li>
</ul>
</li>
</ul>
<h3 id="文件的读写方式"><a href="#文件的读写方式" class="headerlink" title="文件的读写方式"></a>文件的读写方式</h3><ul>
<li><strong>顺序读写</strong>：按文件的逻辑地址顺序读取，主要用于磁带文件，也适用于磁盘上的顺序存储的文件</li>
<li><strong>直接读写（随机读写）</strong>：文件指针可以定位到指定逻辑块，无需一块一块地移动指针</li>
<li><strong>索引读写</strong>：建立索引表，包含键值与逻辑号。通过搜索索引找到键值对应的逻辑块号，再读出需要的记录信息</li>
</ul>
<h2 id="文件的物理结构与组织"><a href="#文件的物理结构与组织" class="headerlink" title="文件的物理结构与组织"></a>文件的物理结构与组织</h2><ul>
<li><strong>连续文件（顺序文件）</strong>：将一个文件中逻辑上连续的信息存放到存储介质依次相邻的物理块上便形成顺序结构</li>
<li><strong>链接文件</strong>：一个文件的信息存放在若干不连续的物理块中，各块之间通过指针链接<ul>
<li>隐式链接文件</li>
<li>显示链接文件：把用于链接文件各物理块的指针，显式地存放在内存的文件访问表 (FAT)。文件的控制块FCB中存放每一条链的链首指针所对应的盘块号：FAT表项中存入链接指针，即下一个块号。</li>
</ul>
</li>
<li><strong>索引文件</strong>：系统为每个文件建立一个索引表，表中每一栏目指出文件信息所在的逻辑块号和与之对应的物理块号。索引表的物理地址则由文件说明信息项（文件目录）给出。</li>
</ul>
<h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><ul>
<li><strong>文件控制块</strong>(File Control Block, FCB)：操作系统为管理文件而设置的一组具有固定格式的数据结构，存放了为管理文件所需的所有属性信息（文件属性或元数据）。文件控制块一般应包括文件标志和控制信息、逻辑结构信息、物理结构信息、使用信息、管理信息等。文件控制块的作用就是操作系统和要处理的文件之间相联系的一条纽带，操作系统要依靠FCB中的数据完成对文件的读或写操作。</li>
<li><strong>文件目录</strong>：管理文件名和文件物理位置之间的映射关系</li>
<li><strong>目录结构</strong><ul>
<li>单级目录结构<ul>
<li>优点：简单；能实现按名存取</li>
<li>缺点：查找费时；重名问题；不利于文件共享</li>
</ul>
</li>
<li>两级目录结构：在第一级目录（主文件目录）下为每用户单独建立一个用户文件目录<ul>
<li>优点：有利于文件的管理、共享和保护：适用于多用户系统，不同的用户可以命名相同文件名的文件，一定程度上解决了命名冲突的问题</li>
<li>缺点：没有从根本上解决文件数目过大时，同一个用户文件目录下的命名冲突的问题与文件搜索时间较长的问题</li>
</ul>
</li>
<li>多级目录结构（树型目录结构）：每个文件系统有一个根目录，在根目录中可以包含若干子目录和文件，在子目录中不但可以包含文件，而且还可以包含下一级子目录。<ul>
<li>优点：用户可以将不同类型和不同功能的文件分类储存，既方便文件管理和查找，还允许不同文件目录中的文件具有相同的文件名</li>
<li>Windows、Unix、Linux、DOS</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="空闲空间的管理"><a href="#空闲空间的管理" class="headerlink" title="空闲空间的管理"></a>空闲空间的管理</h2><ul>
<li>位示图</li>
<li>空闲块列表</li>
<li>空闲链表法<ul>
<li>空闲块链<br>  <img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E7%A9%BA%E9%97%B2%E5%9D%97%E9%93%BE.png" alt="空闲块链"></li>
<li>成组链接法(Unix&#x2F;Linux)：系统中，将空闲块分成若干组，每100 个空闲块为一组，每组的第一个空闲块登记了下一组空闲块的<strong>空闲块总数</strong>和<strong>物理盘块号</strong>。如果一组的第一个空闲块号等于0，则意味着该组是最后一组<br>  <img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%95.png" alt="成组链接法"></li>
</ul>
</li>
</ul>
<h2 id="I-O系统"><a href="#I-O系统" class="headerlink" title="I&#x2F;O系统"></a>I&#x2F;O系统</h2><ul>
<li>I&#x2F;O端口：I&#x2F;O控制器中CPU能访问的各类寄存器<ul>
<li>独立编址：专用的I&#x2F;O端口编址，需要有专用的I&#x2F;O指令</li>
<li>统一编址：内存映射，占用内存，执行时间增加</li>
</ul>
</li>
<li>设备控制器的功能<ul>
<li>数据缓冲</li>
<li>差错控制</li>
<li>数据交换</li>
<li>标识和报告设备的状态</li>
<li>接收和识别命令</li>
<li>地址识别</li>
</ul>
</li>
</ul>
<h3 id="设备数据传输控制方法"><a href="#设备数据传输控制方法" class="headerlink" title="设备数据传输控制方法"></a>设备数据传输控制方法</h3><ul>
<li>轮询方式：CPU不断循环测试I&#x2F;O设备的状态端口</li>
<li>中断控制方式</li>
<li>DMA(Direct Memory Access)方式：CPU向DMA控制器下达指令，让其处理数据的传送，完毕后再把信息反馈给CPU</li>
<li>通道方式</li>
</ul>
<h2 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h2><ul>
<li>缓解设备之间速度差异的矛盾</li>
<li>缓解设备之间传输数据大小不一致的矛盾</li>
<li>支持应用程序I&#x2F;O的语义复制</li>
</ul>
<h3 id="缓冲区的分类"><a href="#缓冲区的分类" class="headerlink" title="缓冲区的分类"></a>缓冲区的分类</h3><ul>
<li>硬件缓冲：为了协调系统和硬件之间的数据传输速度的差异<ul>
<li>Cache(高速缓冲寄存器)、硬盘缓存区</li>
</ul>
</li>
<li>内存缓冲：内存中规划处一个存放系统输入或输出数据的缓冲区<ul>
<li>Linux的页缓存</li>
</ul>
</li>
<li>软件缓冲</li>
</ul>
<h3 id="缓冲技术的分类"><a href="#缓冲技术的分类" class="headerlink" title="缓冲技术的分类"></a>缓冲技术的分类</h3><ul>
<li>单缓冲：一般情况下缓冲区与物理块大小一样，缓冲区移到用户空间后立即请求另一块。适用于数据生产者设备与消费者设备之间的速率相差较大的情况</li>
<li>双缓冲与多缓冲：进程读取缓冲区数据的同时另一缓冲区也在存放数据，适用于数据生产者设备与消费者设备之间的速率相差不大的情况</li>
<li>缓冲池：系统维护着inq(输入缓冲队列)、outq(输出缓冲队列)、emq(空缓冲队列)和hin、sin、hout、sout四个工作缓冲区<br>  <img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/%E7%BC%93%E5%86%B2%E6%B1%A0.png" alt="缓冲池"></li>
</ul>
<h3 id="虚拟设备"><a href="#虚拟设备" class="headerlink" title="虚拟设备"></a>虚拟设备</h3><p>通过虚拟技术将一台独占设备虚拟成多台逻辑设备，供多个用户进程同时使用。</p>
<ul>
<li>设备分配<ul>
<li>静态分配（独占设备）</li>
<li>动态分配（共享设备）</li>
<li>虚拟分配（虚拟设备）</li>
</ul>
</li>
</ul>
<h2 id="大容量存储器"><a href="#大容量存储器" class="headerlink" title="大容量存储器"></a>大容量存储器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">磁盘的大小 = 磁头数 × 柱面数 × 扇区数 × 每个扇区的大小</span><br><span class="line">磁头数 = 盘面数 × 2</span><br><span class="line">柱面数表示磁盘每面盘片有几条磁道</span><br><span class="line">扇区数表示每条磁道上有几个扇区，每个扇区的大小一般是512B</span><br><span class="line"></span><br><span class="line">磁盘读写时间 = 寻道时间 + 旋转延迟 + 数据传输</span><br></pre></td></tr></table></figure>

<h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><h4 id="先来先服务-First-Come-First-Served-FCFS-调度算法-1"><a href="#先来先服务-First-Come-First-Served-FCFS-调度算法-1" class="headerlink" title="先来先服务(First Come First Served, FCFS)调度算法"></a>先来先服务(First Come First Served, FCFS)调度算法</h4><p>根据进程请求访问磁盘的先后顺序进行调度</p>
<h4 id="最短寻道时间优先-Shortest-Seek-Time-First-SSTF-调度算法"><a href="#最短寻道时间优先-Shortest-Seek-Time-First-SSTF-调度算法" class="headerlink" title="最短寻道时间优先(Shortest Seek Time First, SSTF)调度算法"></a>最短寻道时间优先(Shortest Seek Time First, SSTF)调度算法</h4><p>处理距离当前磁头位置的最短寻道时间的请求，可能导致饥饿</p>
<h4 id="扫描-SCAN-调度算法"><a href="#扫描-SCAN-调度算法" class="headerlink" title="扫描(SCAN)调度算法"></a>扫描(SCAN)调度算法</h4><p>从一端到另一端后反转</p>
<h4 id="循环扫描-Circle-SCAN-C-SCAN-调度算法"><a href="#循环扫描-Circle-SCAN-C-SCAN-调度算法" class="headerlink" title="循环扫描(Circle SCAN, C-SCAN)调度算法"></a>循环扫描(Circle SCAN, C-SCAN)调度算法</h4><p>从一端到另一端后，立即返回到开头并且不处理回程的请求</p>
<h4 id="LOOK调度算法"><a href="#LOOK调度算法" class="headerlink" title="LOOK调度算法"></a>LOOK调度算法</h4><p>在SCAN算法基础上只需要移动到最远的请求，不用到末端</p>
<h2 id="EulerOS操作系统"><a href="#EulerOS操作系统" class="headerlink" title="EulerOS操作系统"></a>EulerOS操作系统</h2><ul>
<li>特点<ul>
<li>全面支持鲲鹏处理器</li>
<li>极致性能</li>
<li>高可靠&#x2F;高保障</li>
<li>高安全</li>
<li>支持容器</li>
</ul>
</li>
<li>华为 STaaS(Storage as a Service, STaas)解决方案提供自动化的存储服务发放和智能数据管理，支持关键业务云化，助力客户数据中心云化转型。</li>
</ul>
<h3 id="系统功能特性"><a href="#系统功能特性" class="headerlink" title="系统功能特性"></a>系统功能特性</h3><ul>
<li>系统管理<ul>
<li>系统守护进程systemd</li>
<li>文件系统</li>
<li>glibc库</li>
<li>RAS技术（可靠性、有效性、适合性）</li>
<li>负载均衡技术</li>
<li>内核热补丁</li>
<li>TSX（事务性同步扩展）特性</li>
<li>备电关核</li>
</ul>
</li>
<li>网络<ul>
<li>网络链路故障检测</li>
<li>bbr算法</li>
<li>ipvlan接口</li>
<li>IPv6</li>
<li>监听队列哈希桶元素</li>
</ul>
</li>
<li>内存管理<ul>
<li>内存大页vma管理特性</li>
<li>per_cpu变量内存</li>
<li>Page Cache管理</li>
<li>内存预留</li>
</ul>
</li>
<li>处理器调度<ul>
<li>高性能自旋锁（MCS锁）</li>
<li>用户态进程禁抢占</li>
<li>高性能定时器</li>
<li>中断均衡irqbalance</li>
</ul>
</li>
<li>调测运维<ul>
<li>监控报警</li>
<li>Kbox</li>
<li>Kdump</li>
<li>日志</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author_group"><a class="post-copyright__author_img" target="_blank" rel="noopener" href="https://github.com/wawaoo0210"><img class="post-copyright__author_img_front" src="/img/pwa/sheep.png"></a><div class="post-copyright__author_name">Wawa</div><div class="post-copyright__author_desc"></div></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div id="quit-box" onclick="RemoveRewardMask()"></div></div></div><div class="social-share"><a class="social-share-ico icon-qq" target="_blank" rel="noopener" href="https://connect.qq.com/widget/shareqq/index.html?url=https%3A%2F%2Fwawaoo0210.github.io%2F2025%2F01%2F05%2F%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E5%25A4%258D%25E4%25B9%25A0%25E6%2595%25B4%25E7%2590%2586%2F&amp;title=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86&amp;desc=undefined&amp;summary=undefined&amp;site=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86&amp;pics=%2Fimages%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86%2Fcover.jpg" title="分享到QQ"><i class="solitude fab fa-qq"></i></a><a class="social-share-ico icon-weibo" target="_blank" rel="noopener" href="http://service.weibo.com/share/share.php?url=https%3A%2F%2Fwawaoo0210.github.io%2F2025%2F01%2F05%2F%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E5%25A4%258D%25E4%25B9%25A0%25E6%2595%25B4%25E7%2590%2586%2F&amp;title=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86&amp;pic=%2Fimages%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86%2Fcover.jpg" title="分享到微博"><i class="solitude fab fa-weibo"></i></a><a class="social-share-ico icon-twitter" target="_blank" rel="noopener" href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fwawaoo0210.github.io%2F2025%2F01%2F05%2F%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E5%25A4%258D%25E4%25B9%25A0%25E6%2595%25B4%25E7%2590%2586%2F&amp;text=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86" title="分享到Twitter"><i class="solitude fab fa-twitter"></i></a><a class="social-share-ico icon-facebook" target="_blank" rel="noopener" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fwawaoo0210.github.io%2F2025%2F01%2F05%2F%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E5%25A4%258D%25E4%25B9%25A0%25E6%2595%25B4%25E7%2590%2586%2F" title="分享到Facebook"><i class="solitude fab fa-facebook"></i></a><a class="social-share-ico icon-telegram" target="_blank" rel="noopener" href="https://t.me/share/url?url=https%3A%2F%2Fwawaoo0210.github.io%2F2025%2F01%2F05%2F%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E5%25A4%258D%25E4%25B9%25A0%25E6%2595%25B4%25E7%2590%2586%2F&amp;text=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86" title="分享到Telegram"><i class="solitude fab fa-telegram"></i></a><a class="social-share-ico icon-whatsapp" target="_blank" rel="noopener" href="https://api.whatsapp.com/send?text=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86 https%3A%2F%2Fwawaoo0210.github.io%2F2025%2F01%2F05%2F%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E5%25A4%258D%25E4%25B9%25A0%25E6%2595%25B4%25E7%2590%2586%2F" title="分享到WhatsApp"><i class="solitude fab fa-whatsapp"></i></a><a class="social-share-ico icon-linkedin" target="_blank" rel="noopener" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A%2F%2Fwawaoo0210.github.io%2F2025%2F01%2F05%2F%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%25E5%25A4%258D%25E4%25B9%25A0%25E6%2595%25B4%25E7%2590%2586%2F&amp;title=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86&amp;summary=undefined&amp;source=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86" title="分享到LinkedIn"><i class="solitude fab fa-linkedin"></i></a><div class="social-share-ico icon-link" onclick="utils.copy(&quot;https://wawaoo0210.github.io/2025/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/&quot;)" title="复制文章链接"><i class="solitude fas fa-link"></i></div><div class="social-share-ico icon-qrcode" title="使用手机扫码阅读这篇文章"><i class="solitude fas fa-qrcode"></i><div class="share-main"><div class="share-main-all"><div id="qrcode"></div><div class="reward-dec">使用手机扫码阅读这篇文章</div></div></div><script pjax>typeof QRCode === 'function' && new QRCode(document.getElementById("qrcode"), {
    text: 'https://wawaoo0210.github.io/2025/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/',
    correctLevel : QRCode.CorrectLevel.L
});
window.addEventListener('DOMContentLoaded', () => {
    new QRCode(document.getElementById("qrcode"), {
        text: 'https://wawaoo0210.github.io/2025/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/',
        correctLevel : QRCode.CorrectLevel.L
    });
});
</script></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans">CC BY-NC-SA 4.0</a>协议，完整转载请注明来自<a href="/">Wawa</a></span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%8D%E4%B9%A0/"><span class="tags-punctuation"><i class="solitude fa-solid fa-hashtag"></i>复习<span class="tagsPageCount">3</span></span></a></div></div></div><nav class="needEndHide pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2025/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AE%80%E7%AD%94%E9%A2%98/"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络简答题</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><div class="author-info__top-group"><div class="author-info__sayhi" id="author-info__sayhi" onclick="sco.changeSayHelloText()">sayhello.morning</div></div></div><div class="avatar-img-group"><img class="avatar-img" alt="头像" src="/img/pwa/sheep.png"></div><div class="author-info__description_group"><div class="author-info__description"></div><div class="author-info__description2"></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" target="_blank" rel="noopener" href="https://github.com/wawaoo0210"><div class="author-info__name">Wu Jiayang</div><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon" target="_blank" rel="noopener" href="https://github.com/wawaoo0210" title="Github"><i class="solitude  fab fa-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="solitude fa-solid fa-bars"></i><span>文章目录</span></div><div class="toc-content" id="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86"><span class="toc-text">操作系统复习整理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">操作系统的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3"><span class="toc-text">操作系统接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-text">操作系统结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-text">虚拟机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-text">进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-text">进程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C"><span class="toc-text">程序的顺序执行和并发执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E5%BE%81"><span class="toc-text">进程的定义与特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-text">进程的状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%BB%88%E6%AD%A2"><span class="toc-text">进程的创建与终止</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-text">线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-text">进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5"><span class="toc-text">进程的互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-text">进程的同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-text">进程之间的通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-text">管程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-text">&#x3D;&#x3D;死锁产生的必要条件&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-text">死锁的处理方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2"><span class="toc-text">死锁的预防</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D"><span class="toc-text">死锁的避免</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-text">死锁的检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E9%99%A4"><span class="toc-text">死锁的解除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6"><span class="toc-text">处理器调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-text">调度策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-text">分级调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-First-Come-First-Served-FCFS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">先来先服务(First Come First Served, FCFS)调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">优先级调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88-Shortest-Job-First-SJF-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">最短作业优先(Shortest Job First, SJF)调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88-Highest-Response-Ratio-Next-HRRN-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">最高响应比优先(Highest Response Ratio Next, HRRN)调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AE%E8%BD%AC-RR-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">轮转(RR)调度算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E6%96%B9%E6%A1%88"><span class="toc-text">内存空间连续分配方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-text">分页存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-text">地址变换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-text">段式存储管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF"><span class="toc-text">虚拟存储技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-text">请求分页存储管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA-FIFO-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">先进先出(FIFO)页面置换算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E4%BC%98-OPT-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">最优(OPT)页面置换算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8-LRU-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">最久未使用(LRU)页面置换算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%86%B2%E7%AE%97%E6%B3%95"><span class="toc-text">页面缓冲算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E5%B8%A7%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-text">页帧分配算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E5%B8%A7%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-text">页帧分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%8A%96%E5%8A%A8"><span class="toc-text">系统抖动</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">文件系统层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-text">文件的逻辑结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%E6%96%B9%E5%BC%8F"><span class="toc-text">文件的读写方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BB%84%E7%BB%87"><span class="toc-text">文件的物理结构与组织</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86"><span class="toc-text">目录管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-text">空闲空间的管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O%E7%B3%BB%E7%BB%9F"><span class="toc-text">I&#x2F;O系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-text">设备数据传输控制方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%8A%80%E6%9C%AF"><span class="toc-text">缓冲技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">缓冲区的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%8A%80%E6%9C%AF%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">缓冲技术的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E8%AE%BE%E5%A4%87"><span class="toc-text">虚拟设备</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E5%AE%B9%E9%87%8F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-text">大容量存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="toc-text">磁盘调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-First-Come-First-Served-FCFS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-1"><span class="toc-text">先来先服务(First Come First Served, FCFS)调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88-Shortest-Seek-Time-First-SSTF-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">最短寻道时间优先(Shortest Seek Time First, SSTF)调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F-SCAN-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">扫描(SCAN)调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F-Circle-SCAN-C-SCAN-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">循环扫描(Circle SCAN, C-SCAN)调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LOOK%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">LOOK调度算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EulerOS%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">EulerOS操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7"><span class="toc-text">系统功能特性</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="solitude fa-solid fa-map"></i><span>最近发布</span></div><div class="aside-list"><a class="aside-list-item" href="/2025/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="操作系统复习整理"><div class="thumbnail"><img alt="操作系统复习整理" src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/cover.jpg"></div><div class="content"><span class="title" href="/2025/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="操作系统复习整理">操作系统复习整理</span><span class="article-recent_post_categories" href="/2025/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/">操作系统</span></div></a><a class="aside-list-item" href="/2025/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AE%80%E7%AD%94%E9%A2%98/" title="计算机网络简答题"><div class="thumbnail"><img alt="计算机网络简答题" src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AE%80%E7%AD%94%E9%A2%98/cover.webp"></div><div class="content"><span class="title" href="/2025/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AE%80%E7%AD%94%E9%A2%98/" title="计算机网络简答题">计算机网络简答题</span><span class="article-recent_post_categories" href="/2025/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AE%80%E7%AD%94%E9%A2%98/">计算机网络</span></div></a><a class="aside-list-item" href="/2025/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="计算机网络复习整理"><div class="thumbnail"><img alt="计算机网络复习整理" src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AE%80%E7%AD%94%E9%A2%98/cover.webp"></div><div class="content"><span class="title" href="/2025/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/" title="计算机网络复习整理">计算机网络复习整理</span><span class="article-recent_post_categories" href="/2025/01/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/">计算机网络</span></div></a></div></div></div></div></main><footer id="footer"><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div class="copyright">© 2025 By&nbsp;<a class="footer-bar-link" href="/"><img class="author-avatar" src="/img/pwa/sheep.png">Wu Jiayang</a></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/everfu/hexo-theme-solitude" alt="Theme">Theme</a></div></div></div></footer></div><!-- right_menu--><!-- inject body--><div><script src="/js/utils.js?v=2.1.15"></script><script src="/js/main.js?v=2.1.15"></script><script src="/js/third_party/waterfall.min.js?v=2.1.15"></script><script src="https://fastly.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="https://fastly.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script><script src="/js/tw_cn.js?v=2.1.15"></script><script src="https://fastly.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>window.paceOptions = {
  restartOnPushState: false
}

utils.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')
</script><script src="https://fastly.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div class="js-pjax"></div></div><!-- pjax--><script>const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: ["title","#body-wrap","#site-config","meta[name=\"description\"]",".js-pjax","meta[property^=\"og:\"]","#config-diff",".rs_show",".rs_hide"],
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
})

document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
})

document.addEventListener('pjax:complete', () => {
    window.refreshFn()

    document.querySelectorAll('script[data-pjax]').forEach(item => {
        const newScript = document.createElement('script')
        const content = item.text || item.textContent || item.innerHTML || ""
        Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
        newScript.appendChild(document.createTextNode(content))
        item.parentNode.replaceChild(newScript, item)
    })

    GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

})

document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
        pjax.loadUrl('/404.html')
    }
})</script><!-- google adsense--><!-- search--><!-- Tianli-Talk--><!-- music--></body></html>
        <script>
            const posts = ["2025/01/05/操作系统复习整理/","2025/01/05/计算机网络简答题/","2025/01/05/计算机网络复习整理/"];
            function toRandomPost() {
                const randomPost = posts[Math.floor(Math.random() * posts.length)];
                pjax.loadUrl(GLOBAL_CONFIG.root + randomPost);
            }
        </script>